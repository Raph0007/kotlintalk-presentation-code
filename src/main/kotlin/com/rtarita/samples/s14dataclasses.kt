package com.rtarita.samples

// If you have coded at least one Java DTO before, you know the pain
// Things you need:
// - Definition of fields (ideally with 'final')
// - All-Args Constructor (manual initialization of every field)
// - Getter for every field
// - If not 'final': Setter for every field
// - hashCode()
// - equals()
// - toString()
// All these things are actually trivial to implement, so imagine if a programming language could generate these and even more functionality for you!
// Well, Kotlin does: 'data class'es
data class DataClass(
    val firstProperty: String,
    val secondProperty: Int,
    val thirdProperty: Char
)

// Let's look at the functionality this class offers
fun main() {
    val instance1 = DataClass("Hello, World!", 42, 'c') // all-args constructor
    val instance2 = DataClass("Hello, World!", 42, 'c') // different instance but equal fields

    // getter, kinda... in Kotlin it is usual to make properties public because you can still define custom getter/setter logic for them
    // but in the generated bytecode, every property will have a getter and a setter for interoperability with Java
    // same goes for setters if we had used 'var' instead of 'val'
    println(instance1.secondProperty)

    // this is an actual hashcode, we get the same hashcode for different instances with the same fields
    // if a class does not override hashCode(), every instance has a (conceptually) unique hashcode, but this is not the case here
    println(instance1.hashCode())
    println(instance2.hashCode())

    // same goes for 'equals()', the default implementation from 'Any' only checks referential equality
    // but data classes generate a field-based 'equals()' implementation for us
    println(instance1 == instance2) // '==' is an overloaded operator that calls 'equals()'. Referential equality in Kotlin is checked with '==='

    // toString() will be called by `println()` automatically, just like in Java
    println(instance1)
    println(instance2)

    // Is there more? Yes!
    val test = instance1.component1() // what is this?

    // 'componentN()' are operator functions that enable destructuring, therefore we can do this with every data class instance:
    val (first, second, third) = instance1

    // And then there's also 'copy()', but it can do more than just copying.
    // This function has an argument list that is equal to the property list of the class.
    // When we copy a data class instance, we can optionally specify certain properties we want to change:
    val mutatedInstance1 = instance1.copy(secondProperty = 5)

    println(instance1)
    println(mutatedInstance1)
    println(instance1 == mutatedInstance1)
}